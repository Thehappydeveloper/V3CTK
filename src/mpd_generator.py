from lxml import etree
import os
import json
import re
from datetime import timedelta
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Union
from isodate import parse_duration, duration_isoformat

class V3CMPDBuilder:
    NS = {
        None: "urn:mpeg:dash:schema:mpd:2011",
        "v3c": "urn:mpeg:mpegI:v3c:2020",
        "v3ctk": "urn:v3ctk:tile-boundaries",
    }
    VIDEO_COMPONENT_SCHEME = "urn:mpeg:mpegI:v3c:2020:videoComponent"
    TILE_ID_SCHEME = "urn:v3ctk:tileID"  # private scheme; no official MPEG URN exists for tile IDs

    def __init__(
        self,
        duration="PT10S",
        minBufferTime="PT1S",
        profiles=None,
        mpd_type="static",
        segment_duration_ms=1000,
        media_presentation_duration_ms: Optional[int] = None,
        base_url: Optional[str] = None,
    ):
        mpd_attrib = {
            "type": mpd_type,
            "minBufferTime": minBufferTime,
            "mediaPresentationDuration": self._duration_iso(
                media_presentation_duration_ms, duration
            ),
        }

        if profiles is not None:
            mpd_attrib["profiles"] = profiles

        self.mpd = etree.Element(
            "MPD",
            nsmap=self.NS,
            **mpd_attrib,
        )

        self.mpd.text = "\n  "
        self.segment_duration_ms = segment_duration_ms
        self.total_duration_ms = (
            media_presentation_duration_ms
            or int(parse_duration(duration).total_seconds() * 1000)
        )
        self._mpd_base_dir = None
        self._base_url = base_url

    # =========================
    # PUBLIC METHOD
    # =========================
    def build_from_source(self, tiles_path, boundaries_json_path=None, output_path=None, split_components=True):
        """
        Generate an MPD from a prepared folder structure and optional JSON with tile boundaries.
        Writes the result to output_path when provided; otherwise returns the XML string.
        """
        self._mpd_base_dir = os.path.dirname(output_path) if output_path else None

        tiles = self._discover_tiles(tiles_path, split_components)

        if self._base_url:
            self._add_base_url(self._base_url)

        period = self._add_period()
        self._add_comment(period, "Generated by v3ctk (bin segments, component-split)")

        for tile_id in sorted(tiles.keys(), key=self._tile_sort_key):
            reps = tiles[tile_id]
            self._emit_tile(period, tile_id, reps, split_components)

        # EventStream for tile boundaries
        if boundaries_json_path:
            if os.path.exists(boundaries_json_path):
                with open(boundaries_json_path, "r") as f:
                    boundaries_data = json.load(f)
                self._generate_event_stream(period, boundaries_data)
            else:
                raise FileNotFoundError(f"Boundaries JSON file not found: {boundaries_json_path}")

        self._indent(self.mpd)
        mpd_str = etree.tostring(self.mpd, pretty_print=True, encoding="UTF-8", xml_declaration=True).decode("utf-8")

        if output_path:
            os.makedirs(os.path.dirname(output_path), exist_ok=True)
            with open(output_path, "w", encoding="utf-8") as f:
                f.write(mpd_str)
            print(f"MPD written to {output_path}")

        return mpd_str

    # =========================
    # PRIVATE METHODS
    # =========================
    def _discover_tiles(self, tiles_path: str, split_components: bool):
        tiles_dir = Path(tiles_path)
        if not tiles_dir.exists():
            raise FileNotFoundError(f"Tiles path not found: {tiles_path}")

        tile_dirs = [p for p in tiles_dir.iterdir() if p.is_dir()]
        if not tile_dirs:
            raise ValueError(f"No tile directories found in {tiles_path}")

        tiles: Dict[Union[str, int], List[Dict]] = {}
        for tdir in tile_dirs:
            tile_id, qp = self._parse_tile_descriptor(tdir.name)
            comps = self._collect_components(tdir, split_components)
            entry = {"path": tdir, "qp": qp, "components": comps, "name": tdir.name}
            tiles.setdefault(tile_id, []).append(entry)
        return tiles

    def _parse_tile_descriptor(self, name: str) -> Tuple[Union[str, int], Optional[Tuple[int, int, int]]]:
        """
        Attempt to parse a directory name like '<prefix>_tile_0_occ24_geo32_attr8'
        to recover tile id and qp triple. Falls back to trailing digits for tile id.
        """
        m = re.search(r"tile[_-]?(\d+)_occ(\d+)_geo(\d+)_attr(\d+)", name)
        if m:
            return int(m.group(1)), (int(m.group(2)), int(m.group(3)), int(m.group(4)))
        # Fallback: just capture tile id
        m = re.search(r"tile[_-]?(\d+)", name)
        if m:
            return int(m.group(1)), None
        # Last resort: digits at end or raw string
        trailing = re.search(r"(\d+)$", name)
        if trailing:
            return int(trailing.group(1)), None
        return name, None

    def _collect_components(self, tile_dir: Path, split_components: bool) -> Dict[str, Path]:
        comps: Dict[str, Path] = {}
        expected = ["atlas", "geom", "occp", "attr"] if split_components else ["combined"]
        missing = []
        for comp in expected:
            c_path = tile_dir / comp
            if c_path.is_dir():
                comps[comp] = c_path
            else:
                missing.append(comp)
        if missing:
            raise FileNotFoundError(f"Missing component folder(s) {', '.join(missing)} for tile {tile_dir.name}")
        return comps

    def _emit_tile(self, period, tile_id, reps: List[Dict], split_components: bool):
        tile_label = self._tile_label(tile_id)
        banner = "=" * 56
        self._add_comment(period, banner)
        self._add_comment(period, f"Tile {tile_label} (shared atlas; matching geom/occp/attr qualities)")
        self._add_comment(period, banner)

        reps_sorted = sorted(reps, key=self._quality_key)
        for idx, rep in enumerate(reps_sorted, 1):
            rep["rank"] = idx
            rep["label"] = f"q{idx}"

        adaptation_ids = {}
        if split_components:
            atlas_rep = reps_sorted[:1]  # atlas is shared; take the best-ranked set
            adaptation_ids["atlas"] = self._build_component_adaptation(
                period, tile_id, tile_label, "atlas", atlas_rep, note="shared across qualities"
            )
            for comp in ("geom", "occp", "attr"):
                comp_reps = self._dedupe_reps_by_component(comp, reps_sorted)
                adaptation_ids[comp] = self._build_component_adaptation(
                    period, tile_id, tile_label, comp, comp_reps, quality_note=True
                )
        else:
            adaptation_ids["combined"] = self._build_component_adaptation(
                period, tile_id, tile_label, "combined", reps_sorted, quality_note=True
            )

        if split_components:
            # Preselection groups geometry/occp/attr for this tile
            self._add_preselection(period, tile_label, adaptation_ids)

    def _generate_event_stream(self, period, boundaries_data):
        self._add_comment(period, "EventStream: Tile boundaries (timescale = segment duration)")
        event_stream = etree.SubElement(
            period,
            "EventStream",
            schemeIdUri="urn:v3ctk:tile-boundaries",
            value="v1",
            timescale="1000"
        )
        for idx, segments in sorted(boundaries_data.items(), key=lambda kv: int(kv[0])):
            event = etree.SubElement(
                event_stream,
                "Event",
                id=str(idx),
                presentationTime=str((int(idx) - 1) * self.segment_duration_ms),
                duration=str(self.segment_duration_ms)
            )
            tb = etree.SubElement(event, "{urn:v3ctk:tile-boundaries}TileBoundaries")
            for t_idx, t in enumerate(segments):
                tile_id = t.get("id", t.get("tile_id", t_idx))
                etree.SubElement(
                    tb,
                    "{urn:v3ctk:tile-boundaries}Tile",
                    id=str(tile_id),
                    xmin=str(t["xmin"]),
                    xmax=str(t["xmax"]),
                    ymin=str(t["ymin"]),
                    ymax=str(t["ymax"]),
                    zmin=str(t["zmin"]),
                    zmax=str(t["zmax"]),
                )

    # =========================
    # XML ELEMENT HELPERS
    # =========================
    def _mpd_path(self, path: Union[str, Path]):
        p = Path(path)
        if self._mpd_base_dir:
            try:
                p = Path(os.path.relpath(p, self._mpd_base_dir))
            except ValueError:
                pass
        return p.as_posix()

    def _add_period(self, period_id="P0", start="PT0S"):
        return etree.SubElement(self.mpd, "Period", id=period_id, start=start)

    def _add_base_url(self, url: str):
        bu = etree.SubElement(self.mpd, "BaseURL")
        bu.text = url
        bu.tail = "\n  "
    def _add_adaptation_set(self, period, set_id, mimeType, codecs=None):
        attrib = dict(id=set_id, mimeType=mimeType, segmentAlignment="true", startWithSAP="1")
        if codecs:
            attrib["codecs"] = codecs
        return etree.SubElement(period, "AdaptationSet", **attrib)


    def _add_comment(self, parent, text: str):
        comment = etree.Comment(f" {text} ")
        parent.append(comment)
        comment.tail = "\n  "
        return comment

    def _build_component_adaptation(
        self,
        period,
        tile_id,
        tile_label,
        comp_name,
        reps: List[Dict],
        note: Optional[str] = None,
        quality_note: bool = False
    ):
        """Create one AdaptationSet for a tile component (atlas/geom/occp/attr/combined)."""
        human_name = {
            "atlas": "Atlas",
            "geom": "Geom",
            "occp": "Occp",
            "attr": "Attr",
            "combined": "Combined stream",
        }.get(comp_name, comp_name)

        comment = f"{human_name} ({tile_label})"
        details = []
        if quality_note and len(reps) > 1:
            details.append("representations sorted by quality (lower QP first)")
        if note:
            details.append(note)
        if details:
            comment = f"{comment} â€” {'; '.join(details)}"
        self._add_comment(period, comment)

        aset_id = f"{tile_label}_{comp_name}"

        aset_codecs = None
        rep_codecs = None

        # You need _add_adaptation_set to accept codecs=None and omit the attribute.
        aset = self._add_adaptation_set(period, aset_id, "application/octet-stream", aset_codecs)

        if comp_name != "combined":
            # Private tile ID: better as SupplementalProperty (not required to decode)
            etree.SubElement(aset, "SupplementalProperty", schemeIdUri=self.TILE_ID_SCHEME, value=str(tile_id))

        if comp_name not in ("atlas", "combined"):
            # V3CVideoComponent descriptor per your excerpt:
            # EssentialProperty with schemeIdUri "...:videoComponent", containing <v3c:videoComponent type="..."/>
            # Ensure self.VIDEO_COMPONENT_SCHEME == "urn:mpeg:mpegI:v3c:2020:videoComponent"
            self._add_essential_property(aset, self.VIDEO_COMPONENT_SCHEME, v3cType=comp_name)

        for rep in reps:
            comp_path = rep["components"].get(comp_name)
            if not comp_path:
                raise FileNotFoundError(f"Component '{comp_name}' missing for tile {tile_label} in {rep['name']}")

            seg_files = self._list_segments(comp_path)
            if not seg_files:
                raise FileNotFoundError(f"No segments found for {comp_name} in {comp_path}")

            init_path = self._find_init(comp_path)

            rep_id = f"{tile_label}_{comp_name}_{rep['label']}"
            bandwidth = self._compute_bandwidth(seg_files)

            # You need _add_representation to accept codecs=None and omit the attribute.
            rep_el = self._add_representation(aset, rep_id, bandwidth, rep_codecs)

            if rep.get("qp"):
                qp = rep["qp"]
                self._add_comment(rep_el, f"QP triple: occ={qp[0]}, geo={qp[1]}, attr={qp[2]}")

            media_pattern = comp_path / "segment_$Number$.bin"
            self._add_segment_template(
                rep_el,
                initialization=init_path,
                media=media_pattern,
                probe_segment=seg_files[0]
            )

        return aset_id

    def _add_preselection(self, period, tile_label: str, adaptation_ids: Dict[str, str]):
        # Spec: first id in preselectionComponents is the "main" AdaptationSet
        # In your structure, treat atlas as main when present.
        components: List[str] = []
        if adaptation_ids.get("atlas"):
            components.append(adaptation_ids["atlas"])
        for c in ("geom", "occp", "attr"):
            if adaptation_ids.get(c):
                components.append(adaptation_ids[c])

        if len(components) < 2:
            return

        self._add_comment(period, f"Preselection for {tile_label} (binds atlas+geom+occp+attr)")
        presel = etree.SubElement(
            period,
            "Preselection",
            id=f"pre_{tile_label}",
            tag=tile_label,
            preselectionComponents=" ".join(components),
        )

        # V3C descriptor omitted per project requirements

    def _add_essential_property(self, adaptation_set, schemeIdUri, value=None, v3cType=None):
        prop = etree.SubElement(adaptation_set, "EssentialProperty", schemeIdUri=schemeIdUri)
        if value:
            prop.attrib["value"] = str(value)
        if v3cType:
            etree.SubElement(prop, "{urn:mpeg:mpegI:v3c:2020}videoComponent", type=v3cType)
        return prop

    def _add_segment_template(self, target_element, initialization, media, probe_segment=None):
        if not initialization or not os.path.exists(initialization):
            raise FileNotFoundError(f"Initialization file missing: {initialization}")
        if probe_segment and not os.path.exists(probe_segment):
            raise FileNotFoundError(f"Segment file missing: {probe_segment}")

        init_for_mpd = self._mpd_path(initialization)
        media_for_mpd = self._mpd_path(media)

        etree.SubElement(
            target_element,
            "SegmentTemplate",
            timescale="1000",
            duration=str(self.segment_duration_ms),
            initialization=init_for_mpd,
            media=media_for_mpd,
            startNumber="1"
        )

    def _add_representation(self, adaptation_set, rep_id, bandwidth, codecs=None):
        attrib = dict(id=rep_id, bandwidth=str(bandwidth))
        if codecs:
            attrib["codecs"] = codecs
        return etree.SubElement(adaptation_set, "Representation", **attrib)


    # =========================
    # BANDWIDTH HELPER
    # =========================
    def _list_segments(self, comp_path: Path) -> List[str]:
        segment_files = []
        for f in comp_path.iterdir():
            if f.name.startswith("segment_") and f.suffix == ".bin":
                segment_files.append(f)
        def _seg_idx(p: Path):
            m = re.search(r"segment_(\d+)", p.name)
            return int(m.group(1)) if m else p.name
        segment_files.sort(key=_seg_idx)
        return [str(p) for p in segment_files]

    def _find_init(
        self,
        comp_path: Path,
        fallback: Optional[str] = None,
        allow_fallback: bool = False,
    ) -> str:
        init_path = comp_path / "init.bin"
        if init_path.exists():
            return str(init_path)
        if allow_fallback and fallback:
            return fallback
        raise FileNotFoundError(f"init.bin missing in {comp_path}")

    def _tile_label(self, tile_id) -> str:
        if isinstance(tile_id, int):
            return f"tile{tile_id}"
        s = str(tile_id)
        return s if s.startswith("tile") else f"tile{s}"

    def _quality_key(self, rep: Dict) -> Tuple:
        """
        Sort representations so that lower QP values (better quality) come first,
        falling back to name for deterministic ordering when QP is missing.
        """
        qp = rep.get("qp")
        if qp:
            return (qp[0], qp[1], qp[2], rep["name"])
        return (float("inf"), float("inf"), float("inf"), rep["name"])

    def _tile_sort_key(self, tile_id):
        if isinstance(tile_id, int):
            return (0, tile_id)
        return (1, str(tile_id))

    def _dedupe_reps_by_component(self, comp_name: str, reps: List[Dict]) -> List[Dict]:
        """
        Drop duplicate representations for a given component when they resolve to identical
        segment/init payloads. Keeps the first occurrence to preserve ordering.
        """
        seen = set()
        unique: List[Dict] = []
        for rep in reps:
            comp_path = rep["components"].get(comp_name)
            if not comp_path:
                continue
            sig = self._component_signature(comp_path)
            if sig in seen:
                continue
            seen.add(sig)
            unique.append(rep)
        return unique

    def _component_signature(self, comp_path: Path) -> Tuple:
        """
        Build a deterministic signature for a component folder based on init/segment sizes and counts.
        This avoids expensive content hashing while still catching identical payloads in different paths.
        """
        segments = self._list_segments(comp_path)
        init_path = self._find_init(
            comp_path,
            fallback=segments[0] if segments else None,
            allow_fallback=True,
        )
        init_size = os.path.getsize(init_path)
        seg_sizes = tuple(os.path.getsize(s) for s in segments)
        return (init_size, len(seg_sizes), seg_sizes)

    def _duration_iso(self, duration_ms: Optional[int], fallback_iso: str) -> str:
        if duration_ms is None:
            return fallback_iso
        return duration_isoformat(timedelta(milliseconds=duration_ms))

    def _indent(self, elem, level=0):
        """
        Manual pretty-print with comments respected; ensures consistent whitespace for readability.
        """
        indent_str = "\n" + "  " * level
        if len(elem):
            if not elem.text or not elem.text.strip():
                elem.text = indent_str + "  "
            for child in elem:
                self._indent(child, level + 1)
            if not elem[-1].tail or not elem[-1].tail.strip():
                elem[-1].tail = indent_str
        else:
            if not elem.text or not elem.text.strip():
                elem.text = None
        if level and (not elem.tail or not elem.tail.strip()):
            elem.tail = "\n" + "  " * (level - 1)
    def _compute_bandwidth(self, file_list):
        """
        Compute bandwidth per segment: each segment's bits / segment duration in seconds.
        For the last segment, duration may be shorter if leftover exists.
        Returns max segment bandwidth in bits/sec.
        """
        if not file_list:
            raise ValueError("No segment files provided for bandwidth computation.")

        num_segments = len(file_list)
        segment_durations = [self.segment_duration_ms] * num_segments
        if self.total_duration_ms:
            last_duration = self.total_duration_ms - (self.segment_duration_ms * (num_segments - 1))
            if last_duration > 0:
                segment_durations[-1] = last_duration

        max_bw = 0
        for f, dur in zip(file_list, segment_durations):
            if not os.path.exists(f):
                raise FileNotFoundError(f"Segment file missing: {f}")
            bw = os.path.getsize(f) * 8 * 1000 / dur  # bits/sec
            max_bw = max(max_bw, bw)
        return int(max_bw)
